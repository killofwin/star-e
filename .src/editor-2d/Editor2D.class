' Gambas class file

' Editor2D
' Класс содержащий необходимые методы для 2D редактора юнитов

Public Const Editor2dRangeMinID As Integer = 10000 ' Минимальное значение содержащее данные редактора 
Public Const Editor2dRangeMaxID As Integer = 90000 ' Максимальное значение содержащее данные редактора
 
Public Const Editor2dPartUnitMorfid As Integer = 10001 ' ID редактора PartUnit морфидов
Public Const Editor2dUnitMorfid As Integer = 10002 ' ID редактора Unit морфидов

Public Const PropertyPartUnitTypeSymmetry As Integer = 0 ' тип симетрии морфидов
 ' 0 - чётность симметрии не важна
 ' 1 симметрия начиная с нечётного
 ' 2 симметрия начиная с чётного

Public Const PropertyPartUnitMorfidName As Integer = 0  ' Имя
Public Const PropertyPartUnitMorfidX As Integer = 1 ' X координата крепления
Public Const PropertyPartUnitMorfidY As Integer = 2 ' Y координата крепления
Public Const PropertyPartUnitMorfidZ As Integer = 3 ' Z координата крепления
Public Const PropertyPartUnitMorfidAppointment As Integer = 4 ' назначение части морфида 0-голова, 1 - конечность, 9 - хвост

Public Const PropertyPartUnitMorfidFilePicture2 As Integer = 3  ' Имя файла с картинкой для чётной конечности
Public Const PropertyPartUnitMorfidFilePicture As Integer = 4  ' Имя файла с картинкой (для нечётной конечности)
Public Const PropertyPartUnitMorfidDescription As Integer = 5  ' Описание юнита

Public Const PropertyPartUnitMorfidMaskD As Integer = 5 ' маска дублирования
Public Const PropertyPartUnitMorfidMaskB As Integer = 6 ' маска блокирования

Public Const PropertyPartUnitMorfidSymmetryString As Integer = 5  ' Строка по которой проверяеться симметрия

' Как работать с данным классом, каждая констата является индексом нужных данных в соответствующем массиве объекта
' GameObjectData
' Что позволяет вместо цифр использовать констаты указатели
' К примеру что бы узнать имя объекта нужно обратиться так
' Name = GameObjectData.Strings[PropertyPartUnitName]
' Что бы узнать X надо сделать так
' X = GameObjectData.IntegerValues[PropertyPartUnitX]
' Тип значения следует знать заранее и жёстко кодировать в процедуре редактирования, 
' видимо для каждого типа юнитов и частей юнитов нужен будет свой редактор
' 

Public Const CountUnitXYZ As Integer = 31 ' ((3 * 10) + 1) ' колличество целых чисел в массиве для описания координат всех частей юнита
Public Const PropertyUnitMorfidName As Integer = 0  ' Имя
Public Const PropertyUnitMorfidFilePicture As Integer = 4  ' Имя файла с картинкой
Public Const PropertyUnitMorfidDescription As Integer = 5  ' Описание юнита
' Использовать GetPartUnitMorfidX/Y/Z для определения координат крепления


Public Const MorfidMaxLimb As Integer = 8 ' Максимальное колличество лап у морфида первого типа.



Public GameObjectData As GameObjectDataClass ' ссылка на редактируемый объект

Public Sub NewGameObjectData(Optional ID As Integer = Editor2dPartUnitMorfid)
  ' Создаёт новый экземпляр для редактора
  GameObjectData = New GameObjectDataClass ' создание нового пустого объекта
  
  If ID = Editor2dPartUnitMorfid Then
    ' Создаёт описание для новой части морфида
    GameObjectData.IntegerValues.Resize(6 + 1) ' создать несколько новых элементов
    GameObjectData.Strings.Resize(6 + 1) ' создать несколько новых элементов
  End If
  If ID = Editor2dUnitMorfid Then
    ' Создаёт описание для нового морфида
    GameObjectData.IntegerValues.Resize(CountUnitXYZ) ' создать слоты для крепления частей
    GameObjectData.Strings.Resize(5 + 1) ' создать описание
  End If
  
End

Public Function NewBlankGameObjectData(Optional ID As Integer = Editor2dPartUnitMorfid) As GameObjectDataClass
  ' Создаёт новый экземпляр для редактора Но непосредственно возвращает значение
  Dim BlankGODC As New GameObjectDataClass  ' создание нового пустого объекта
  
  If ID = Editor2dPartUnitMorfid Then
    ' Создаёт описание для новой части морфида
    BlankGODC.IntegerValues.Resize(6 + 1) ' создать несколько новых элементов
    BlankGODC.Strings.Resize(6 + 1) ' создать несколько новых элементов
  End If
  If ID = Editor2dUnitMorfid Then
    ' Создаёт описание для нового морфида
    BlankGODC.IntegerValues.Resize(CountUnitXYZ) ' создать слоты для крепления частей
    BlankGODC.Strings.Resize(5 + 1) ' создать описание
  End If
  
  Return BlankGODC ' возврат значения
  
End


Public Function GetPartUnitMorfidX(Unit2D As GameObjectDataClass, n As Integer) As Integer
  'Вычисляет X координату n части Editor2dUnitMorfid
  'Unit2D - это ссылка на 2D описание морфида первого типа
  Dim r As Integer ' результат
  If Unit2D.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = Unit2D.IntegerValues[(n * 3) + 1]
  Endif
  Return r
End
Public Function GetPartUnitMorfidY(Unit2D As GameObjectDataClass, n As Integer) As Integer
  'Вычисляет Y координату n части Editor2dUnitMorfid
  Dim r As Integer ' результат
  If Unit2D.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = Unit2D.IntegerValues[(n * 3) + 2]
  Endif
  Return r
End
Public Function GetPartUnitMorfidZ(Unit2D As GameObjectDataClass, n As Integer) As Integer
  'Вычисляет Z координату n части Editor2dUnitMorfid
  Dim r As Integer ' результат
  If Unit2D.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = Unit2D.IntegerValues[(n * 3) + 3]
  Endif
  Return r
End
 



' Проверки симетричности морфид.

Public Function SymmetryMorfidTrue(UnitMorfid As UnitClass) As Integer
  ' Функция возвращает True если Морфид собран в 2D редакторе симетрично. 
  ' Возвращает значение отличное от True если какая то часть не валидна, в битовой маске этого числа
  ' обозначены неисправные конечности.
  ' Поэтому проверку на неправильность конечностей надо делать if r <> True , а не if r = false 
  ' О как!
  
  ' Она обращает внимание лишь на godc классы редактора ID которого записан в констате Editor2dPartUnitMorfid
  ' Для реального игрового контроля будет использоваться другой механизм, в котором клиентом на сервер будет передаваться
  ' список файлов из которых в дальнейшем и будет сформирован юнит. А так же список генетических программ которые
  ' будут задействованы в юните
  ' Генетическая программа это тригер и действие. Тригером может служить фермент или достижение нужной массы определённой частью.
  ' А действие как выработка другого фермента, так и команда на рост, апоптоз или морфирование определённой части в другую.
  ' По сути это будут простейшие линейные скриптыиспользующие в качестве условий ферментные флаги.
  ' Так же некоторые юниты смогут распылять произвольные ферменты при помощи желез запуская те или иные последовательности
  ' в других юнитах
  Dim a As Integer
  Dim b As Integer
  Dim bc As Integer ' дополнительный счётчик
  Dim p As Integer
  Dim m As Integer
  Dim PartsGODC As New GameObjectDataClass[] ' ссылки на нужные godc свойства частей юнита
    
  Dim tp As Integer ' указатель в UnitMorfid.Parts[a].OtherValues
  Dim r As Integer ' результат
  Dim Parity As Boolean ' чётность конечности
  
  Dim SymD As New Boolean[] ' проверить дублиование тех конечностей которые отмечены как True (дублирование)
  Dim SymB As New Boolean[] ' проверить отсутствие тех конечностей которые помечены как True (блокирование)ъ
  Dim SymStrings As New String[] ' Ожидаемая строка проверки симметрии
  
  Dim UMC As Integer
  
  p = UnitMorfid.Parts.Max ' максимальный индекс
  UMC = UnitMorfid.Parts.Count ' Общее колличество элементов включая 0
  
  SymD.Resize(UMC)
  SymB.Resize(UMC) 
  SymStrings.Resize(UMC)
  ' Изменение размеров массивов до размерности массива конечностей
      
  r = True
  
  If UMC > 1 Then 
    ' В начале было If UMC < 1 Then 
    ' У юнита есть части
    PartsGODC.Resize(UMC) 
    For a = 0 To p
      ' Присвоение ссылок заранее для облегчения кодирования
      tp = UnitMorfid.Parts[a].OtherValues.FindID(Editor2dPartUnitMorfid)  ' ссылка на данные редактора морфидов
      If tp <> -1 Then
        'Данные по конечности найдены
        PartsGODC[a] = UnitMorfid.Parts[a].OtherValues.Values[tp] ' Собственно сама ссылка
      Endif
      If tp = -1 Then
        ' часть создавалась явно не как Editor2dPartUnitMorfid 
        PartsGODC[a] = NewBlankGameObjectData(Editor2dPartUnitMorfid)  ' присвоить пустышку 'изначально тут использовался вызов функции с параметрами "по умолчанию" но это делало код менее очевидным, исправил.
      Endif
    Next
    
    'Print "ololo max " & Str(p)
    For a = 0 To p 'перебор частей
      Print "ololo" & Str(a)
      If r = False Then Break ' досрочный выход если результат уже отрицательный 
      'Если проверка провалилась на раннем этапе, если она не провалилась, значит надо проверить каждую часть на валидность
      
      If a > p Then Break ' На всякий случай, а то мало ли что :)
      
      If a > 1 Then
        Parity = Not Parity ' инвертирование чётности . Значение True значит что конечность чётная
      Endif
      
      If (SymB[a] Or SymD[a]) = False Then ' Конечность не является не блокированной и не дублированной
        ' Теперь надо проверить на своём ли она месте
        If PartsGODC[a].IntegerValues[PropertyPartUnitTypeSymmetry] = 2 Then
          ' Конечность должна быть чётной
          If Parity = False And a > 0 Then r = False ' Но конечность НЕчётная и не нулевая.
        Endif
        If PartsGODC[a].IntegerValues[PropertyPartUnitTypeSymmetry] = 1 Then
          ' Конечность должна быть НЕчётной
          If Parity = True And a > 0 Then r = False ' Но конечность чётная и не нулевая.
        Endif
        
        If r <> False Then 'конечность прошла предыдущую проверку, (она на своём месте)
          'Теперь последует проверка на маски, не выхядят ли они за границы колличества конечностей
          
          ' А теперь надо наиболее изящным образом организовать проверку
          ' Думаю сначала следует вычислить не являеться ли число больше чем оставшееся к перебору колличество конечностей
          ' Полагаю стоит вычислить позиции максимального бита.
           
           If (a + MaxBit(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskD])) - 1 > MorfidMaxLimb Then
             'Если колличечество конечностей больше лимита конечностей
             'Проверяеться по маске дублирования
             If r = True Then r = False ' что бы не манипулировать битами отрицательного числа
             r = BSet(r, a - 1) ' присовение нужного бита, функция BSet(Number, bit) считает биты начиная с 0 нулевого.
           Endif
           
           
           bc = 0 ' Установка битов блокирования
           For b = a + 1 To p
             bc = bc + 1 ' бит из маски который следует считать
             'А теперь считываем нужный бит из битовой маски
             If SymB[b] <> True Then
               SymB[b] = BTst(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskB], bc) ' Необходимо пояснение, чуть сам не запутался:
             Endif
             ' Есть условие, оно необходимо что бы симметрия не оказалась отменена, она может только быть присвонной TRUE
             ' от нуля до p все конечности        принимает аргументы c нуля
             ' Симметрия рассматривается включительно, то есть нулевой бит в маске указывает на саму же конечность, поэтому он игнорируется.
             ' сделано так для упрощения попыток вообразить себе всё это
           Next
           
           bc = 0 ' Установка битов дублирования
           For b = a + 1 To p
             bc = bc + 1 ' бит из маски который следует считать
             'А теперь считываем нужный бит из битовой маски
             If SymD[b] <> True Then 
               SymD[b] = BTst(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskD], bc) ' присваиваем бит
               SymStrings[b] = PartsGODC[a].Strings[PropertyPartUnitMorfidSymmetryString] ' присвоение строки по которой проверяется симметрия
             Endif
             
           Next
        Endif 'конечность прошла предыдущую проверку, (она на своём месте)
      Endif ' Конечность не является не блокированной и не дублированной
      
      ' Бит блокировки на дублированной конечности делает её блокированной, при этом дублирование не рассматривается
      ' То есть если на конечности есть бит блокировки, то бит дублирование рассматриваеться как дополнительная опция
      ' в расчёте выхода колличества конечностей за предел (8 лап) и означает недопустимость выхода за этот предел.
      If SymD[a] = True And SymB[a] = False Then
        ' Дублированная конечность (без бита блокировки)
        ' Всё из за проверки вылазанья конечности за максимальное колличество по маске дублирования
        ' Конечность считается истинно блокированной лишь если на ней есть бит блокирования и нет бита дублирования
        ' Иначе конечность просто дублированная.
        ' Если за пределы максимума вылазиет просто блокировка, то она не нарушает симметрию, 
        ' а если вылазиет блокировка-дублирование значит конечность требует крепления не только в начальном слоте.
        ' В качестве примера можно привести крылья и многоножку. Крыло может быть большим и блокировать другие конечности, 
        ' но если крылья будут крайними, то ничему они мешать не будут.
        ' А вот "многоножка" это совокупность отдельных ножек и каждая из них должна крепиться к туловищу. 
        ' Поэтому для крыльев просто блокирование, а для многоножки блокирование-дублирование.
        
        ' Надо проверить равно ли свойство конечности строке симметрии
        If PartsGODC[a].Strings[PropertyPartUnitMorfidSymmetryString] <> SymStrings[a] Then
          ' Таки не равно, значит надо внечти в результат соответствующую маску
          ' Если что, нулевая конечность вне симметрии, но -1 надо всё равно сделать, потому что BSet считает первый бит нулевым
          r = BSet(r, a - 1) ' собственно присвоение
        Endif
      Endif
      
      If SymB[a] = True Then
        ' Блокированная конечность
        ' Надо проверить равно ли свойство конечности ""
        If PartsGODC[a].Strings[PropertyPartUnitMorfidSymmetryString] <> "" Then
          ' Таки не равно, значит надо внечти в результат соответствующую маску
          ' Если что, нулевая конечность вне симметрии, но -1 надо всё равно сделать, потому что, потому что BSet считает первый бит нулевым
          r = BSet(r, a - 1) ' собственно присвоение
        Endif  
      Endif
      
      
      
  
    Next 'перебор частей
  
  Endif
    
  Return r  
End

Public Function GetSymmetryDuplication(Part As PartUnitClass) As Boolean[]
  'Функция возвращает в виде битовой маски симметрию дублирования части
  'Данная функция универсальна и работает со всем созданными в 2D редакторе (первом) проектами частей юнитов
  Dim r As New Boolean[32] ' результат в массиве размером 32 бита, 
  ' больше смысла нет, так как переменная определяющая симметрию занимает 32 бита (на 32 разрядных системах)
  ' Нулевой бит отвечает за саму же конечность и игнорируеться.
  ' Анализ результатов следует проводить с элемента 1.
  ' На всякий случай в качестве ограничителя счётчика используйте переменную со значением r.Max
  ' Использование же числа 31 = (32 - 1) может привести к несовместимости если процедура симметрии будет изменена на более сложную
  
  Dim GODC As New GameObjectDataClass ' содержит нужные данные редактора
  Dim LinkGODC As Integer ' ссылка на данные редактора в свойствах части юнита.
  
  Dim a As Integer ' счётчик циклов
  Dim b As Integer ' второй счётчик
  Dim m As Integer
  
  LinkGODC = Part.OtherValues.FindRangeID(Editor2dRangeMinID, Editor2dRangeMaxID)  ' Для начала ищем описания характерные для Editor2D
  
  If LinkGODC <> -1 Then
    'свойство найдено
    If TypeOf(Part.OtherValues.Values[LinkGODC]) = TypeOf(GODC) Then GODC = Part.OtherValues.Values[LinkGODC] ' присвоение ссылки для удобства (но только если типы совпадают)
    
    If LinkGODC = Editor2dPartUnitMorfid Then ' это часть морфида первого типа
      ' а теперь вычислим симметрию дублирования этой части 
      m = r.Max
      For a = 1 To m
        'симметрия рассматриваеться включительно, то есть нулевой бит в маске указывает на саму же конечность
        r[a] = BTst(GODC.IntegerValues[PropertyPartUnitMorfidMaskD], a) ' считываем маску дублирования по битам из переданной части
      Next
    Endif
    
    ' Другие типы юнитов 2D редактора
    
  Endif
  
  Return r
End

Public Function GetSymmetryBlocking(Part As PartUnitClass) As Boolean[]
  'Функция возвращает в виде битовой маски симметрию блокирования части
  'Данная функция универсальна и работает со всем созданными в 2D редакторе (первом) проектами частей юнитов
  Dim r As New Boolean[32] ' результат в массиве размером 32 бита, 
  ' больше смысла нет, так как переменная определяющая симметрию занимает 32 бита (на 32 разрядных системах)
  ' Нулевой бит отвечает за саму же конечность и игнорируеться.
  ' Анализ результатов следует проводить с элемента 1.
  ' На всякий случай в качестве ограничителя счётчика используйте переменную со значением r.Max
  ' Использование же числа 31 = (32 - 1) может привести к несовместимости если процедура симметрии будет изменена на более сложную
  
  Dim GODC As New GameObjectDataClass ' содержит нужные данные редактора
  Dim LinkGODC As Integer ' ссылка на данные редактора в свойствах части юнита.
  
  Dim a As Integer ' счётчик циклов
  Dim b As Integer ' второй счётчик
  Dim m As Integer
  
  LinkGODC = Part.OtherValues.FindRangeID(Editor2dRangeMinID, Editor2dRangeMaxID)  ' Для начала ищем описания характерные для Editor2D
  
  If LinkGODC <> -1 Then
    'свойство найдено
    If TypeOf(Part.OtherValues.Values[LinkGODC]) = TypeOf(GODC) Then GODC = Part.OtherValues.Values[LinkGODC] ' присвоение ссылки для удобства (но только если типы совпадают)
    
    If LinkGODC = Editor2dPartUnitMorfid Then ' это часть морфида первого типа
      ' а теперь вычислим симметрию блокирования этой части 
      m = r.Max
      For a = 1 To m
        'симметрия рассматриваеться включительно, то есть нулевой бит в маске указывает на саму же конечность
        r[a] = BTst(GODC.IntegerValues[PropertyPartUnitMorfidMaskD], a) ' считываем маску блокирования по битам из переданной части
      Next
    Endif
    
    ' Другие типы юнитов 2D редактора
    
  Endif
  
  Return r
End


Public Function MaxBit(Number As Integer) As Integer ' функция возвращает длинну двоичного представления числа по крайней еденице.
  Dim r As Integer ' результат
  If Number > 0 Then r = Int(Log2(Number)) + 1  ' Log2(x) = Log(x) / Log(2) обрадовало что есть такая встроенная функция
  ' формулу мне предоставили в треде http://iichan.hk/b/res/3007310.html
  Return r ' возврат значения
End


