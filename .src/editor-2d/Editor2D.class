' Gambas class file

' Editor2D
' Класс содержащий необходимые методы для 2D редактора юнитов
 
Public Const Editor2dPartUnitMorfid As Integer = 10001 ' ID редактора PartUnit морфидов
Public Const Editor2dUnitMorfid As Integer = 10002 ' ID редактора Unit морфидов

Public Const PropertyPartUnitTypeSymmetry As Integer = 0 ' тип симетрии морфидов
 ' 0 - чётность симметрии не важна
 ' 1 симметрия начиная с нечётного
 ' 2 симметрия начиная с чётного

Public Const PropertyPartUnitMorfidName As Integer = 0  ' Имя
Public Const PropertyPartUnitMorfidX As Integer = 1 ' X координата крепления
Public Const PropertyPartUnitMorfidY As Integer = 2 ' Y координата крепления
Public Const PropertyPartUnitMorfidZ As Integer = 3 ' Z координата крепления
Public Const PropertyPartUnitMorfidAppointment As Integer = 4 ' назначение части морфида 0-голова, 1 - конечность, 9 - хвост

Public Const PropertyPartUnitMorfidFilePicture As Integer = 4  ' Имя файла с картинкой
Public Const PropertyPartUnitMorfidDescription As Integer = 5  ' Описание юнита

Public Const PropertyPartUnitMorfidMaskD As Integer = 5 ' маска дублирования
Public Const PropertyPartUnitMorfidMaskB As Integer = 6 ' маска блокирования

Public Const PropertyPartUnitMorfidSymmetryString As Integer = 5  ' Строка по которой проверяеться симметрия

' Как работать с данным классом, каждая констата является индексом нужных данных в соответствующем массиве объекта
' GameObjectData
' Что позволяет вместо цифр использовать констаты указатели
' К примеру что бы узнать имя объекта нужно обратиться так
' Name = GameObjectData.Strings[PropertyPartUnitName]
' Что бы узнать X надо сделать так
' X = GameObjectData.IntegerValues[PropertyPartUnitX]
' Тип значения следует знать заранее и жёстко кодировать в процедуре редактирования, 
' видимо для каждого типа юнитов и частей юнитов нужен будет свой редактор
' 

Public Const CountUnitXYZ As Integer = 31 ' ((3 * 10) + 1) ' колличество целых чисел в массиве для описания координат всех частей юнита
Public Const PropertyUnitMorfidName As Integer = 0  ' Имя
Public Const PropertyUnitMorfidFilePicture As Integer = 4  ' Имя файла с картинкой
Public Const PropertyUnitMorfidDescription As Integer = 5  ' Описание юнита
' Использовать GetPartUnitMorfidX/Y/Z для определения координат крепления


Public Const MorfidMaxLimb As Integer = 8 ' Максимальное колличество лап у морфида первого типа.



Public GameObjectData As GameObjectDataClass ' ссылка на редактируемый объект

Public Sub NewGameObjectData(Optional ID As Integer = Editor2dPartUnitMorfid)
  ' Создаёт новый экземпляр для редактора
  GameObjectData = New GameObjectDataClass ' создание нового пустого объекта
  
  If ID = Editor2dPartUnitMorfid Then
    ' Создаёт описание для новой части морфида
    GameObjectData.IntegerValues.Resize(6 + 1) ' создать несколько новых элементов
    GameObjectData.Strings.Resize(6 + 1) ' создать несколько новых элементов
  End If
  If ID = Editor2dUnitMorfid Then
    ' Создаёт описание для нового морфида
    GameObjectData.IntegerValues.Resize(CountUnitXYZ) ' создать слоты для крепления частей
    GameObjectData.Strings.Resize(5 + 1) ' создать описание
  End If
  
End

Public Function NewBlankGameObjectData(Optional ID As Integer = Editor2dPartUnitMorfid) As GameObjectDataClass
  ' Создаёт новый экземпляр для редактора Но непосредственно возвращает значение
  Dim BlankGODC As New GameObjectDataClass  ' создание нового пустого объекта
  
  If ID = Editor2dPartUnitMorfid Then
    ' Создаёт описание для новой части морфида
    BlankGODC.IntegerValues.Resize(6 + 1) ' создать несколько новых элементов
    BlankGODC.Strings.Resize(6 + 1) ' создать несколько новых элементов
  End If
  If ID = Editor2dUnitMorfid Then
    ' Создаёт описание для нового морфида
    BlankGODC.IntegerValues.Resize(CountUnitXYZ) ' создать слоты для крепления частей
    BlankGODC.Strings.Resize(5 + 1) ' создать описание
  End If
  
  Return BlankGODC ' возврат значения
  
End


Public Function GetPartUnitMorfidX(n As Integer) As Integer
  'Вычисляет X координату n части Editor2dUnitMorfid
  Dim r As Integer ' результат
  If GameObjectData.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = GameObjectData.IntegerValues[(n * 3) + 1]
  Endif
  Return r
End
Public Function GetPartUnitMorfidY(n As Integer) As Integer
  'Вычисляет Y координату n части Editor2dUnitMorfid
  Dim r As Integer ' результат
  If GameObjectData.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = GameObjectData.IntegerValues[(n * 3) + 2]
  Endif
  Return r
End
Public Function GetPartUnitMorfidZ(n As Integer) As Integer
  'Вычисляет Z координату n части Editor2dUnitMorfid
  Dim r As Integer ' результат
  If GameObjectData.IntegerValues.Count >= CountUnitXYZ Then
    ' Массив имеет правильный размер
    r = GameObjectData.IntegerValues[(n * 3) + 3]
  Endif
  Return r
End
 



' Проверки симетричности морфид.

Public Function SymmetryMorfidTrue(UnitMorfid As UnitClass) As Integer
  ' Функция возвращает True если Морфид собран в 2D редакторе симетрично. 
  ' Возвращает значение отличное от True если какая то часть не валидна, в битовой маске этого числа
  ' обозначены неисправные конечности.
  '  
  ' Она обращает внимание лишь на godc классы редактора ID которого записан в констате Editor2dPartUnitMorfid
  ' Для реального игрового контроля будет использоваться другой механизм, в котором клиентом на сервер будет передаваться
  ' список файлов из которых в дальнейшем и будет сформирован юнит. А так же список генетических программ которые
  ' будут задействованы в юните
  ' Генетическая программа это тригер и действие. Тригером может служить фермент или достижение нужной массы определённой частью.
  ' А действие как выработка другого фермента, так и команда на рост, апоптоз или морфирование определённой части в другую.
  ' По сути это будут простейшие линейные скриптыиспользующие в качестве условий ферментные флаги.
  ' Так же некоторые юниты смогут распылять произвольные ферменты при помощи желез запуская те или иные последовательности
  ' в других юнитах
  Dim a As Integer
  Dim b As Integer
  Dim bc As Integer ' дополнительный счётчик
  Dim p As Integer
  Dim m As Integer
  Dim PartsGODC As GameObjectDataClass[] ' ссылки на нужные godc свойства частей юнита
    
  Dim tp As Integer ' указатель в UnitMorfid.Parts[a].OtherValues
  Dim r As Integer ' результат
  Dim Parity As Boolean ' чётность конечности
  
  Dim SymD As New Boolean[] ' проверить дублиование тех конечностей которые отмечены как True (дублирование)
  Dim SymB As New Boolean[] ' проверить отсутствие тех конечностей которые помечены как True (блокирование)ъ
  Dim SymStrings As New String[] ' Ожидаемая строка проверки симметрии
  
  Dim UMC As Integer
  
  p = UnitMorfid.Parts.Max ' максимальный индекс
  UMC = UnitMorfid.Parts.Count ' Общее колличество элементов включая 0
  
  SymD.Resize(UMC)
  SymB.Resize(UMC) 
  SymStrings.Resize(UMC)
  ' Изменение размеров массивов до размерности массива конечностей
      
  r = True
  
  If UMC < 1 Then
    ' У юнита есть части
    PartsGODC.Resize(UMC) 
    
    For a = 0 To p
      ' Присвоение ссылок заранее для облегчения кодирования
      tp = UnitMorfid.Parts[a].OtherValues.FindID(Editor2dPartUnitMorfid)  ' ссылка на данные редактора морфидов
      If tp <> -1 Then
        'Данные по конечности найдены
        PartsGODC[a] = UnitMorfid.Parts[a].OtherValues.Values[tp] ' Собственно сама ссылка
      Endif
      If tp = -1 Then
        ' часть создавалась явно не как Editor2dPartUnitMorfid 
        PartsGODC[a] = NewBlankGameObjectData ' присвоить пустышку
        
      Endif
      
    Next
    
    
    
    
    For a = 0 To p
      'перебор частей
      If r = False Then Break ' досрочный выход если результат уже отрицательный 
      'Если проверка провалилась на раннем этапе, если она не провалилась, значит надо проверить каждую часть на валидность
      
      If a > p Then Break ' На всякий случай, а то мало ли что :)
      
      If a > 1 Then
        Parity = Not Parity ' инвертирование чётности . Значение True значит что конечность чётная
      Endif
      
      If (SymB[a] Or SymD[a]) = False Then
        ' Конечность не является не блокированной и не дублированной
         
        ' Теперь надо проверить на своём ли она месте
        If PartsGODC[a].IntegerValues[PropertyPartUnitTypeSymmetry] <> 2 Then
          ' Конечность должна быть чётной
          If Parity = False And a > 0 Then r = False ' Но конечность НЕчётная и не нулевая.
        Endif
        If PartsGODC[a].IntegerValues[PropertyPartUnitTypeSymmetry] <> 1 Then
          ' Конечность должна быть НЕчётной
          If Parity = True And a > 0 Then r = False ' Но конечность чётная и не нулевая.
        Endif
        
        If r <> False Then
          'конечность прошла предыдущую проверку, (она на своём месте)
          'Теперь последует проверка на маски, не выхядят ли они за границы колличества конечностей
          
          ' А теперь надо наиболее изящным образом организовать проверку
          ' Думаю сначала следует вычислить не являеться ли число больше чем оставшееся к перебору колличество конечностей
          ' Полагаю стоит вычислить позиции максимального бита.
           
           If (a + MaxBit(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskD])) - 1 > MorfidMaxLimb Then
             'Если колличечество конечностей больше лимита конечностей 
             If r = True Then r = False ' что бы не манипулировать битами отрицательного числа
             r = BSet(r, a - 1) ' присовение нужного бита, функция BSet(Number, bit) считает биты начиная с 0 нулевого.
           Endif
           
           
           bc = 0 ' Установка битов блокирования
           For b = a + 1 To p
             bc = bc + 1 ' бит из маски который следует считать
             'А теперь считываем нужный бит из битовой маски
             If SymB[b] <> True Then
               SymB[b] = BTst(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskB], bc) ' Необходимо пояснение, чуть сам не запутался:
             Endif
             ' Есть условие, оно необходимо что бы симметрия не оказалась отменена, она может только быть присвонной TRUE
             ' от нуля до p все конечности        принимает аргументы c нуля
             ' симметрия рассматриваеться включительно, то есть нулевой бит в маске указывает на саму же конечность, поэтому он и игнорируеться
             ' сделанно так для упрощения попыток вообразить себе всё это
           Next
           bc = 0 ' Установка битов дублирования
           For b = a + 1 To p
             bc = bc + 1 ' бит из маски который следует считать
             'А теперь считываем нужный бит из битовой маски
             If SymD[b] <> True Then 
               SymD[b] = BTst(PartsGODC[a].IntegerValues[PropertyPartUnitMorfidMaskD], bc) ' присваиваем бит
               SymStrings[b] = PartsGODC[a].Strings[PropertyPartUnitMorfidSymmetryString] ' присвоение строки по которой проверяется симметрия
             Endif
             
           Next
          
          
        Endif
        
        
        
        
         
      Endif ' Конечность не является не блокированной и не дублированной
      
      
      
      
      If SymD[a] = True Then
        ' Дублированная конечность
        
      Endif
      
      If SymB[a] = True Then
        ' Блокированная конечность
        
      Endif
      
      
      
  
    Next
    
    
  Endif
  
  
  
  Return r  
End

Public Function MaxBit(Number As Integer) As Integer ' функция возвращает длинну двоичного представления числа по крайней еденице.
  Dim r As Integer ' результат
  r = Int(Log2(Number)) + 1  ' Log2(x) = Log(x) / Log(2) обрадовало что есть такая встроенная функция
  ' формулу мне предоставили в треде http://iichan.hk/b/res/3007310.html
  Return r ' возврат значения
End

